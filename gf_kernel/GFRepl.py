import io
import os
import re
import sys
from distutils.spawn import find_executable
from subprocess import PIPE, Popen

from IPython.utils.tempdir import TemporaryDirectory

from .utils import parse, parse_command, to_message_format

COMMAND_SEPARATOR = "COMMAND_SEPARATOR===??!<>239'_"


class GFRepl:
    def __init__(self):
        self.td = TemporaryDirectory()
        self.to_clean_up = ['.dot', '.png', '.gfo']

        self.pipe = os.pipe()
        self.gf_shell = Popen((find_executable('gf'), '--run'),
                              stdin=PIPE,
                              stderr=self.pipe[1],
                              stdout=self.pipe[1],
                              text=True,
                              encoding='utf-8')
        self.commandcounter = 0
        self.infile = os.fdopen(self.pipe[0])

        # catch any initial messages
        sep = self.write_separator()
        self.gf_shell.stdin.flush()
        self.initialOutput = self.get_output(sep)

        self.out_count = 0

    def do_shutdown(self):
        """Terminates the GF shell. """
        self.gf_shell.communicate('q\n')
        self.gf_shell.stdin.close()
        self.gf_shell.kill()

    # -------------------------- GF shell communication -------------------------- #

    def write_cmd(self, cmd):
        if not cmd.endswith('\n'):
            cmd += '\n'
        self.gf_shell.stdin.write(cmd)
        self.commandcounter += 1

    def write_separator(self):
        sep = COMMAND_SEPARATOR + str(self.commandcounter)
        self.gf_shell.stdin.write(f"ps \"{sep}\"\n")
        return sep

    def get_output(self, sep):
        """Reads lines until sep found"""
        output = ""
        for line in self.infile:
            if line.rstrip() == sep:
                return output
            if line != '\n':  # ignore empty lines
                output += line

    def handle_gf_command(self, cmd):
        """Forwards a command to the GF Shell and returns the output"""
        self.write_cmd(cmd)
        sep = self.write_separator()
        self.gf_shell.stdin.flush()
        return self.get_output(sep)

    # ------------------------------ Kernel commands ----------------------------- #

    def clean_up(self):
        """Removes all files whose extensions are contained in `self.to_clean_up`"""
        removed = []
        files = os.listdir('.')
        for file in files:
            _, file_extension = os.path.splitext(file)
            if file_extension in self.to_clean_up:
                removed.append(file)
                os.remove(file)

        if removed:
            s = map(lambda x: 'Removed: %s' % x, removed)
            return "\n".join(s)
        else:
            return "No files removed"

    def do_export(self, file_name):
        files = os.listdir(self.td.name)
        file_reg = re.compile('^%s.gf$' % file_name)
        for file in files:
            if file_reg.match(file):
                from shutil import copy2
                copy2(os.path.join(self.td.name, file), file)
                return 'Exported %s' % file
        return 'Could not find %s' % file_name

    def handle_input(self, code):
        """Handles all kinds of user inputs"""
        messages = []
        parse_dict = parse(code)
        if parse_dict['type']:
            if parse_dict['type'] == 'commands':
                for command in parse_dict['commands']:
                    name = command['name']
                    args = command['args']
                    if name == 'view':
                        messages.append(
                            self.handle_multiple_view(command['args']))
                    elif name == 'clean':
                        messages.append(to_message_format(
                            message=self.clean_up()))
                    elif name == 'export':
                        messages.append(to_message_format(
                            message=self.do_export(command['args'])))
                    elif name == 'help':
                        # TODO move this to another external file (probably a json)
                        messages.append(to_message_format("""Available kernel commands: 
view 'gf_command' : view the graph(s) generated by 'gf_command'
clean : remove all %s files from the current directory.
export 'grammar_name' : export the grammar with 'grammar_name' to your current directory
h : display more information on the GF shell commands
Otherwise you can use the kernel as an editor for your grammars.
Stated grammars are automatically imported upon definiton.""" % (", ".join(self.to_clean_up))))
                    else:
                        cmd = '%s %s' % (name, args)
                        msg = self.handle_gf_command(cmd)
                        if name == 'import' and not msg:
                            messages.append(to_message_format(
                                message='Import successful!'))
                        else:
                            messages.append(to_message_format(message=msg))
            else:
                messages.append(to_message_format(
                    message=self.handle_grammar(code, parse_dict['grammar_name'])))

        else:
            messages.append(to_message_format(
                message="Input is neither a valid grammar nor a valid GF shell command!"))

        return messages

    def handle_grammar(self, grammar, name):
        """Handles a grammar imput"""
        file_path = "%s.gf" % (os.path.join(self.td.name, name))
        with io.open(file_path, 'w', encoding='utf-8') as f:
            f.write(grammar)
            f.close()
        out = self.handle_gf_command(
            "import %s.gf" % (os.path.join(self.td.name, name)))
        if not out:
            out = "Defined %s" % name
        return out

    def handle_multiple_view(self, command):
        """Handles view commands with possibly multiple graph outputs"""
        cmd = parse_command(command)
        if cmd['tree_type']:
            raw_command = cmd['cmd']
            out = self.handle_gf_command(raw_command)
            lines = out.split('\n')
            trees = []
            for line in lines:
                if line != '' and line != ' ':
                    trees.append(line)
            if len(trees) > 1:
                return to_message_format(trees=trees, tree_type=cmd['tree_type'])

        return to_message_format(file=self.handle_single_view(command))

    def handle_single_view(self, command):
        """
            Handles a single view command

            Sends the `command` to the GF shell and converts the output to a .png file
            returns the name of the .png file
        """
        out = self.handle_gf_command(command)
        if not out:
            return "no file"

        out_dot = os.path.join(self.td.name, 'out%s.dot' % self.out_count)
        out_png = os.path.join(self.td.name, 'out%s.png' % self.out_count)

        with open(out_dot, 'w') as f:
            f.write(out)

        DOT_ARGS = [
            'dot',
            '-Tpng', out_dot,
            '-o', out_png
        ]
        p = Popen(DOT_ARGS, shell=False)
        p.communicate()
        p.kill()
        self.out_count += 1

        return out_png

    def start(self):
        """Starts the REPL"""
        i = sys.stdin.readline()
        while i and i != 'quit\n' and i != 'q\n':
            # send input without the newline
            print(self.handle_gf_command(i[:-1]))
            i = sys.stdin.readline()


if __name__ == '__main__':
    repl = GFRepl()
    repl.start()
